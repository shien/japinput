# Phase 8: AI 辞書・設定生成（オフライン IME + AI 事前生成）

## 方針

**IME ランタイムはネットワーク非依存で動作する。** AI は辞書・設定・補正テーブルの「素材」を事前に生成する用途に限定する。

```
┌──────────────────────────────┐      ┌──────────────────────────────┐
│ AI（事前生成 / オフライン）   │      │ IME（リアルタイム / 常時）    │
│                              │      │                              │
│ ・ユーザーの要望・職業        │─生成→│ ・SKK 辞書ファイル            │
│ ・入力ログ分析               │      │ ・コンテキスト優先テーブル    │
│ ・タイポパターン生成         │      │ ・タイポ補正テーブル          │
│                              │      │                              │
│ LLM / ローカルモデル         │      │ ネットワーク不要              │
│ 好きなタイミングで実行       │      │ 低レイテンシ                  │
└──────────────────────────────┘      └──────────────────────────────┘
```

### この方針のメリット

- **レイテンシ:** 変換処理に API 通信が挟まらないため、入力体感は従来の IME と同等
- **プライバシー:** 入力内容がリアルタイムで外部に送られない
- **オフライン動作:** ネットワークがなくても完全に動作する
- **柔軟性:** AI の種類を問わない（ChatGPT, Claude, ローカル LLM 等どれでも辞書生成可能）
- **分離性:** IME コアのコードに AI 依存コードが入らず、テスト・保守が容易

## 目標

1. 複数辞書ファイルの読み込みに対応する
2. コンテキスト優先テーブルによる候補並び替えを実装する
3. タイポ補正テーブルによるローマ字入力補正を実装する
4. 確定ログの記録機能を実装する
5. 上記すべてのデータを AI で生成するためのフォーマット仕様を定める

## 前提

- Phase 3 の変換エンジン (`engine.rs`) が動作していること
- `dictionary.rs` の `Dictionary` が SKK 形式を読み込めること
- `candidate.rs` の `CandidateList` が候補ナビゲーションを提供していること

## ファイル構成 (予定)

```
src/
├── dictionary.rs        # 複数辞書読み込み対応 (拡張)
├── candidate.rs         # コンテキスト優先による並び替え (拡張)
├── romaji.rs            # タイポ補正テーブル参照 (拡張)
├── engine.rs            # 確定ログ記録 (拡張)
├── context_priority.rs  # コンテキスト優先テーブル (新規)
├── typo_correction.rs   # タイポ補正テーブル (新規)
├── history.rs           # 確定ログ記録・読み込み (新規)
├── ...
dict/
├── SKK-JISYO.L          # メイン辞書（既存）
├── user_tech.txt         # AI 生成: 技術用語辞書
├── user_templates.txt    # AI 生成: 定型文辞書
├── context_priority.txt  # AI 生成: コンテキスト優先テーブル
├── typo_corrections.txt  # AI 生成: タイポ補正テーブル
```

---

## タスク

### 8.1 複数辞書ファイルの読み込み対応

現在 `Dictionary::load_from_file` は単一ファイルのみ。複数の辞書ファイルをマージして読み込めるようにする。

- [ ] `Dictionary::load_from_files(paths: &[&Path])` を追加
- [ ] 辞書の優先順位: 先に読み込んだファイルの候補が先頭に来る
- [ ] 同一読みの候補は重複排除する（既存の `load_from_file` と同じロジック）
- [ ] テスト: 2つの辞書ファイルをマージした結果の検証

**動作確認:**
- `cargo test` で複数辞書の読み込み・マージテストがパスすること
- 既存の単一辞書テストが壊れていないこと

**AI 生成辞書のフォーマット:**

既存の SKK 辞書形式をそのまま使用する。AI への指示例:

```
「Rust プログラマー向けの技術用語辞書を SKK 形式で生成してください。」

出力例 (dict/user_tech.txt):
;; AI 生成: Rust プログラマー向け技術用語辞書
くれーと /クレート/
とれいと /トレイト/
らいふたいむ /ライフタイム/
でっどろっく /デッドロック/
みゅーてっくす /ミューテックス/
```

定型文辞書も同じ形式:

```
出力例 (dict/user_templates.txt):
;; AI 生成: ビジネス定型文
おつ /お疲れ様です。/
おせ /お世話になっております。/
しょうち /承知いたしました。/
かくにん /確認いたしました。ありがとうございます。/
```

→ 追加実装不要で既存の `Dictionary` がそのまま読み込める。

---

### 8.2 コンテキスト優先テーブルの実装

直前に確定したテキストに含まれるキーワードに基づいて、候補の並び順を変える。

- [ ] `ContextPriority` 構造体を `src/context_priority.rs` に新規作成
- [ ] テーブルファイルの読み込み (`load_from_file`)
- [ ] 候補リストの並び替え関数 (`reorder`)
- [ ] `engine.rs` の `do_convert` でコンテキスト優先を適用
- [ ] テスト: コンテキストによる並び替えの検証

**ファイルフォーマット:**

```
# コンテキスト優先テーブル
# 形式: キーワード(カンマ区切り)<TAB>読み<TAB>優先候補(カンマ区切り)
技術,開発,コード	くらす	クラス
生活,暮らし,住む	くらす	暮らす
新聞,取材,報道	きしゃ	記者
駅,電車,鉄道	きしゃ	汽車
```

**ランタイムの処理:**

1. `do_convert` で辞書から候補リストを取得
2. 確定済みテキスト履歴（直近 N 文字）を参照
3. `ContextPriority::reorder` で候補リストを並び替え
4. 並び替え後のリストで `CandidateList` を生成

キーワードマッチは単純な文字列含有チェック (`str::contains`) で十分。

**動作確認:**
- `cargo test` でコンテキスト優先テーブルの読み込みテストがパスすること
- キーワードマッチによる候補並び替えが正しいことをテストで確認
- キーワードが一致しない場合は元の候補順が維持されること

**AI 生成の指示例:**

```
「以下の同音異義語について、文脈キーワードと優先候補の対応表を生成してください。
形式: キーワード(カンマ区切り)<TAB>読み<TAB>優先候補(カンマ区切り)
対象: きしゃ, くらす, かいほう, しこう, きかん, こうしょう, ...」
```

---

### 8.3 タイポ補正テーブルの実装

辞書検索で候補が見つからない場合、ローマ字の打ち間違いパターンを補正テーブルで修正する。

- [ ] `TypoCorrection` 構造体を `src/typo_correction.rs` に新規作成
- [ ] テーブルファイルの読み込み (`load_from_file`)
- [ ] ローマ字列の補正関数 (`correct`)
- [ ] `engine.rs` の `do_convert` で候補が空のときに補正を試みる
- [ ] テスト: 補正パターンの適用、マッチしない場合は何もしない

**ファイルフォーマット:**

```
# タイポ補正テーブル
# 形式: 誤入力<TAB>正しい入力
kaiig	kaigi
sihyo	shihyou
toukouy	toukyou
puroguraminngu	puroguramingu
```

**ランタイムの処理:**

1. `do_convert` で辞書検索
2. 候補が空の場合、`TypoCorrection::correct` でローマ字列を補正
3. 補正後のローマ字をひらがなに変換し、再度辞書検索
4. 補正候補が見つかれば `CandidateList` を生成

**動作確認:**
- `cargo test` でタイポ補正テーブルの読み込みテストがパスすること
- 誤入力の補正→再変換が正しく動作するテスト
- テーブルに存在しない入力はそのまま通過すること

**AI 生成の指示例:**

```
「日本語のローマ字入力で頻出するタイポパターンを生成してください。
形式: 誤入力<TAB>正しい入力
キーボード配列に基づく隣接キーの打ち間違い、重複打鍵、打鍵順の入れ替わりを網羅してください。」
```

---

### 8.4 確定ログの記録

ユーザーの確定履歴をローカルに記録し、後から AI に分析させるための素材とする。

- [ ] `History` 構造体を `src/history.rs` に新規作成
- [ ] 確定イベントのログ記録 (`record`)
- [ ] ログファイルの書き出し (JSONL 形式)
- [ ] `engine.rs` の確定処理 (`Commit`) でログ記録を呼び出す
- [ ] テスト: ログ記録の検証

**ログフォーマット (JSONL):**

```jsonl
{"reading":"かいぎ","selected":"会議","context":"明日の","timestamp":1709312400}
{"reading":"きしゃ","selected":"記者","context":"新聞の","timestamp":1709312600}
{"reading":"くらす","selected":"クラス","context":"Rustの","timestamp":1709312700}
```

**ログの保存先:** `~/.japinput/history.jsonl`

**動作確認:**
- `cargo test` でログ記録・読み込みのユニットテストがパスすること
- JSONL 形式の出力が仕様通りであること

**AI 分析の指示例:**

```
「以下の入力ログを分析し、ユーザーの変換傾向に基づいた優先辞書を SKK 形式で生成してください。
頻繁に選択される候補は先頭に、ほぼ選択されない候補は除外してください。」
```

---

### 8.5 設定ファイルによる辞書・テーブルのパス管理

複数辞書やテーブルファイルのパスを設定ファイルで管理する。

- [ ] 設定ファイル形式の定義 (TOML)
- [ ] `Config` 構造体と読み込みロジック
- [ ] `engine.rs` 初期化時に設定を読み込む
- [ ] テスト: 設定ファイルの読み込み

**設定ファイル例 (`~/.japinput/config.toml`):**

```toml
[dictionaries]
# 辞書ファイル（上から順に優先）
files = [
    "~/.japinput/dict/SKK-JISYO.L",
    "~/.japinput/dict/user_tech.txt",
    "~/.japinput/dict/user_templates.txt",
]

[context_priority]
# コンテキスト優先テーブル
file = "~/.japinput/dict/context_priority.txt"

[typo_correction]
# タイポ補正テーブル
file = "~/.japinput/dict/typo_corrections.txt"

[history]
# 確定ログの保存先
file = "~/.japinput/history.jsonl"
# ログの最大行数（超えたら古いものから削除）
max_entries = 100000
```

**動作確認:**
- `cargo test` で設定ファイルの読み込みテストがパスすること
- 存在しないファイルが指定された場合にエラーではなくスキップされること

---

## 実装順序

| 順序 | タスク | 依存 | 規模 |
|---|---|---|---|
| 1 | 8.1 複数辞書読み込み | なし | 小 |
| 2 | 8.4 確定ログ記録 | なし | 小 |
| 3 | 8.2 コンテキスト優先テーブル | 8.1 | 中 |
| 4 | 8.3 タイポ補正テーブル | なし | 中 |
| 5 | 8.5 設定ファイル管理 | 8.1〜8.4 | 中 |

8.1 と 8.4 は互いに依存しないため並行して着手可能。

## 完了条件

- 複数辞書ファイルをマージして読み込めること
- コンテキスト優先テーブルで候補順が変わること
- タイポ補正テーブルで誤入力が修正されること
- 確定ログが JSONL 形式で記録されること
- 設定ファイルで各データファイルのパスを管理できること
- AI で生成した辞書・テーブルファイルをそのまま配置して動作すること
- `cargo test` で全テストがパスすること
- `cargo clippy` と `cargo fmt -- --check` がクリーンであること

## 依存 crate (追加予定)

- `toml` — 設定ファイルパース (8.5)
- `serde`, `serde_json` — 確定ログの JSON シリアライズ (8.4)
- `chrono` または `std::time` — タイムスタンプ (8.4)

## 注意事項

- AI 生成ファイルは `dict/` に配置するが、`.gitignore` で除外されているためリポジトリには含まれない
- テスト用のサンプルデータは `tests/fixtures/` に配置する
- IME ランタイムのコードに HTTP クライアントや API 呼び出しのコードは一切入れない
- 辞書・テーブルファイルが存在しない場合はデフォルト動作（補正なし・優先なし）にフォールバックする
